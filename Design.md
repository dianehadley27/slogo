Soravit Sophastienphong, Brian Keohane, Diane Hadley, Pim Chuaylua

#Slogo: Design Document

##Introduction
By writing this program, the team will allow any user the ability to write and run Logo code in an integrated development environment. One of the primary design goals of the project is to encapsulate data between the front end and the back end such that making changes to view will not heavily affect the functionality of the model and vice-versa. Additionally, we want our program to be robust and flexible such that we could add additional features without making major changes to the existing code. In the view, we have a JavaFX window with the command line through which the program receives user input. The view sends this input to the controller in the back-end, which parses the text, interprets the command, and updates the state of the model before sending the data back to the front-end to update the model graphically. When the back-end gets a command from the front-end, it checks whether the command is valid considering the available commands. If the command is invalid, then it sends the data back to the front-end to display an error message and move on to the next input. For the most part, the implementation details of each respective external and internal API will be hidden from others, but the data sent between the view and model will be the most open parts of the program’s design.

##Design Overview
Our program is divided up into four APIs: View Internal, View External, Model Internal, and Model External. 
View Internal - This API is responsible for the styling of the user interface and settings for changing anything related to how the program looks. This includes windows for the turtle, the command line, the console, and the workspace. The classes in the front end containing the internal API are Turtle, CommandLine, Console, Workspace, TurtleSettings, GeneralSettings, DisplayError, HelpWindow, and Data. Turtle, CommandLine, Console, and Workspace will all have public methods getRoot() that the UI will call and add to the current root in order to complete the visualization. CommandLine will also have a method getCommand() which will return a List and Data will call this method. TurtleSettings will contain public methods getBackgroundColor(), getPenColor(), getTurtleImage(), and getRoot() which the UI will call to implement those settings in the scene and insert the comboboxes for those settings. GeneralSettings will contain public method getLanguage() which Data will call and getRoot() which UI will call. DisplayError will contain public method displayErrorDialogBox, which the methods in TurtleSettings will call. HelpWindow will contain public method getRoot(). Data will pass information to the DataSorterr after a command is performed. It will contain the public method getResultsFromController(). DataSorter will then pass information to each corresponding part of the visualization. It will contain public methods getTurtleData(), getConsoleDate(), and getWorkspaceData(). 
